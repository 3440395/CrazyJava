#### 重载方法的原因
- java中的构造器使用了与类名一样的方法名，所以如果不用重载，那类就只有一种构造方
式了（C语言中每个方法必须要有不同的标识符）
- 同一个词赋予不同的含义

#### 清理：终结处理和垃圾回收

- **垃圾回收准备回收一个对象时，先会调用finalize()（我把它理解为试探）,然后在下次执行回收动作的时候开始回
收(可能回收失败，如果他被别的对象引用)，所以可以在finalize中做清理工作。**
- 垃圾回收机只能回收new出来的对象，对于其他方式开辟的内存（**java中一切皆对象，所以其他方式指的就是C方法**），比如通过C创建的，就没法
回收，所以可以在finalize中调用响应的方法去回收。

>例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会
 被一直保存下来。

 对于这段话，我的理解是，一个对象将自己绘制到屏幕上，那么“屏幕”将会持有他的引用，如果没有擦除，
 那么这个 引用一直存在，那么这个对象不会被清除，因为回收机想要回收他的时候，发现他被引用了。这里需要说下回收机的机制：他首先会“试探”某个对象，告诉他，你要被回收，并且回调他的finalize方法，然后下次执行操作的时候，才会真正执行回收操作（不一定可以被回收）
 所以，在finalize中擦除（清空这个引用），然后下次就可以被回收了。

 不要太依赖finalize，而是创建其他清理方法，清理如上那种情况中的擦除。finalize